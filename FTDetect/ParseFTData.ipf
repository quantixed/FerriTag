#pragma TextEncoding = "MacRoman"
#pragma rtGlobals=3		// Use modern global access method and strict wave access.

Menu "Macros"
	"FerriTag distribution...",  AutoFerriTag()
End

// In this version, results of comDet (generated by FindFT.ijm) are stored in a directory called cd
// cd has text files of results and 8-bit TIFFs of the processed images
// The parent images are in the directory above cd (name is not important)
// In the parent directory is another directory called "masks" which has the masks of the images
// Refer to Masks as brother directory to cd
Function AutoFerriTag()
	CoastClear()
	GetPixelData()
	LoadTiffsAndComDet()
End

Function LoadTIFFsAndComDet()
	
	String expDiskFolderName, ParentExpDiskFolderName, BrotherExpDiskFolderName
	String FileList, ThisFile, tifName
	String cdWName, cdIName, cdJName, cdMName
	Variable FileLoop, voxelSize, nWaves, i
	
	NewPath/O/Q/M="Please find disk folder" ExpDiskFolder
	if (V_flag!=0)
		DoAlert 0, "Disk folder error"
		Return -1
	endif
	PathInfo /S ExpDiskFolder
	ExpDiskFolderName = S_path
	// make path to parent directory containing original images
	ParentExpDiskFolderName = RemoveEnding(ExpDiskFolderName,":cd:")
	NewPath/O/Q ParentExpDiskFolder, ParentExpDiskFolderName
	// make path to parent directory containing original images
	BrotherExpDiskFolderName = RemoveEnding(ExpDiskFolderName,":cd:") + ":masks:"
	NewPath/O/Q BrotherExpDiskFolder, BrotherExpDiskFolderName
	// determine how many comdet outputs in cd we will process
	FileList=IndexedFile(expDiskFolder,-1,".txt")
	Variable nFiles=ItemsInList(FileList)
	Make/O/T/N=(nFiles) ImageNameWave
	Make/O/N=(nFiles,4) volumeWave
	Make/O/N=(nFiles) voxelWave
	Make/O/N=(nFiles,3) limitWave
	
	MakeSummaryLayout(nFiles,6)
	
	for (FileLoop = 0; FileLoop < nFiles; FileLoop += 1)
		ThisFile = StringFromList(FileLoop, FileList)
		// load comdet output and make a 2D wave to hold data
		LoadWave/Q/A/J/D/W/O/L={0,1,0,1,3}/P=expDiskFolder ThisFile
		cdWName = "cdW" + num2str(fileLoop)
		Concatenate/O/KILL "Abs_Frame;X__px_;Y__px_;", $cdWName
		Wave cdMat = $cdWName
		// load the processed image
		cdIName = "cdI" + num2str(fileLoop)
		tifName = ReplaceString(".txt", ThisFile, ".tif")
		ImageLoad/T=tiff/N=$cdIName/O/P=expDiskFolder tifName
		Wave imgMat = $cdIName
		// store its name in ImageNameWave
		ImageNameWave[fileLoop] = RemoveEnding(tifName,".tif")
		// load the mask image
		cdMName = "cdM" + num2str(fileLoop)
		// tifName is identical to processed image
		ImageLoad/T=tiff/N=$cdMName/O/P=BrotherExpDiskFolder tifName
		Wave maskMat = $cdMName
		// now process the mask image to get discrete values for each zone
		ProcessMask(maskMat)
		// get area sizes of each zone (in pixels)
		GetVolumes(volumeWave,maskMat,FileLoop)
		
		// now read everything
		ParseComDetData(cdMat,imgMat,maskMat)
		
		// load the parent image
		cdJName = "cdJ" + num2str(fileLoop)
		ImageLoad/T=tiff/N=$cdJName/O/P=ParentExpDiskFolder tifName
		Wave ParentImgMat = $cdJName
		voxelSize = 0.07 * (CheckScale(RemoveEnding(tifName,".tif")))^2
		voxelWave[FileLoop] = voxelSize // in um3
		//scale volumeWave result for this row
		volumeWave[fileLoop][] *= voxelSize
		
		// make the images for the summary layout showing where the spots are
		ImagePlusSpots(ParentImgMat, FileLoop)
		
		KillWaves/Z imgMat,ParentImgMat,maskMat
	endfor
	Killwaves/Z m0,m1,aa,bb,cc,w0,w1,w2
	// Get rid of CMap waves. These are a colorscale that get loaded with 8-bit color TIFFs
	KillCMaps()
	// Count particles which are within zMin and zMax that are in each area
	CountValidParticles()
	CalculateDensities()
	TileLayout(nFiles,6)
End

///	@param	nFiles	total number of TIFFs
///	@param	plotNum	number of plots per page
Function MakeSummaryLayout(nFiles,plotNum)
	Variable nFiles,plotNum
	Variable pgMax = floor((nFiles -1) / plotNum) + 1
	
	Variable i
	
	DoWindow/K SummaryLayout
	NewLayout /N=summaryLayout
	for(i = 1; i < pgMax; i += 1)
		LayoutPageAction/W=summaryLayout appendPage
	endfor
	
	LayoutPageAction size(-1)=(595, 842), margins(-1)=(18, 18, 18, 18)
	ModifyLayout units=0
	ModifyLayout frame=0,trans=1
End

///	@param	maskMat	mask image for processing
Function ProcessMask(maskMat)
	Wave maskMat
	maskMat[][] = (maskMat[p][q] < 20) ? 0 : maskMat[p][q]
	maskMat[][] = (maskMat[p][q] == 125) ? 1 : maskMat[p][q]
	maskMat[][] = (maskMat[p][q] > 240) ? 2 : maskMat[p][q]
	maskMat[][] = (maskMat[p][q] > 19) ? 3 : maskMat[p][q]
	maskMat[1038,*][1002,*] = 3
End

///	@param	volumeWave	matrix to store volume data
///	@param	maskMat	processed mask image
///	@param	i	iteration number (row number)
Function GetVolumes(volumeWave,maskMat,i)
	Wave volumeWave,maskMat
	Variable i
	
	Duplicate/O/FREE maskMat,tempwave
	Variable j
	
	for(j = 0; j < 4; j += 1)
		tempwave[][] = (maskMat[p][q] == j) ? 1 : 0
		volumeWave[i][j] = sum(tempwave)
	endfor
End

/// @param	cdMat	Matrix of ComDet Values
/// @param	imgMat	Tiff file
/// @param	maskMat	brother image with the mask of locations
Function ParseComDetData(cdMat,imgMat,maskMat)
	WAVE cdMat,imgMat,maskMat
	
	Variable xDim = dimsize(imgMat, 0)
	Variable yDim = dimsize(imgMat, 1)
	Make/O/U/B/N=(xDim,yDim) m0,m1
	
	String mName = NameOfWave(cdMat)
	String qName = ReplaceString("cdW",mName,"cdQ")
	
	Variable xx,yy
	Variable nSpots
	Variable xL,xR,yT,yB
	Variable locVar
	
	Variable i
	
	nSpots = dimsize(cdMat,0)
	// Make matrix to hold results
	// 0, mean; 1, SD; 2, SNR; 3, quality; 4, location
	Make/O/N=(nSpots,5) $qName
	Wave qW = $qName
	
	for(i = 0; i < nSpots; i += 1)
		xx = round(cdMat[i][1])
		yy = round(cdMat[i][2])
		// make mask for signal
		m0 = 1
			xL = limit(xx-2,0,xDim-1)
			xR = limit(xx+1,0,xDim-1)
			yT = limit(yy-2,0,yDim-1)
			yB = limit(yy+1,0,yDim-1)
		m0[xL,xR][yT,yB] = 0
		//calculate mean
		ImageStats/R=m0 imgMat
		// store mean
		qW[i][0] = V_avg
		// make mask for noise
		m1 = 1
			xL = limit(xx-9,0,xDim-1)
			xR = limit(xx+8,0,xDim-1)
			yT = limit(yy-9,0,yDim-1)
			yB = limit(yy+8,0,yDim-1)
		m1[xL,xR][yT,yB] = 0
			xL = limit(xx-6,0,xDim-1)
			xR = limit(xx+5,0,xDim-1)
			yT = limit(yy-6,0,yDim-1)
			yB = limit(yy+5,0,yDim-1)
		m1[xL,xR][yT,yB] = 1
		// Calculate SD
		ImageStats/R=m1 imgMat
		// Store SD
		qW[i][1] = V_sdev
		// SNR
		qW[i][2] = qW[i][0]/qW[i][1]
		// location in mask
		// 0 is outside, 1 is in the cell, 2 is at the membrane, 3 is NaN, should be no 4s
		qW[i][4] = maskMat[xx][yy]
	endfor
	WaveStats/Q/RMD=[][0,0] qW
	// 4th column now contains Z-score of mean not SNR
	qW[][3] = (qW[p][0] - V_avg) / V_sdev
End

///	@param	txtName	accepts the string ThisFile
Function CheckScale(txtName)
	String txtName
	
	Wave/T/Z FileName
	Wave/Z PixelSize
	Wave/Z matA
	Variable pxSize
	
	if (!WaveExists(FileName) || !WaveExists(PixelSize))
		Abort "I need two waves: FileName and PixelSize"
	endif
	FindValue/TEXT=txtName FileName
	if (V_Value == -1)
		Print txtName, "didn't scale"
	endif
	
	// PixelSize is in nm per pixel so convert to um
	pxSize = PixelSize[V_Value] / 1000
	return pxSize
End

///	@param	ParentImgMat	Image for addition of spots
///	@param	imgNum	variable containing image sequence suffix (easier than parsing it out)
Function ImagePlusSpots(ParentImgMat, imgNum)
	Wave ParentImgMat
	Variable imgNum
	
	String imgName = NameOfWave(ParentImgMat)
	String cdWName = ReplaceString("cdJ",imgName,"cdW")
	Wave cdW = $cdWName
	String spotName = ReplaceString("cdJ",imgName,"spot")
	String cdQName = ReplaceString("cdJ",imgName,"cdQ")
	Wave cdQWave = $cdQName
	WAVE/Z/T ImageNameWave
	WAVE/Z LimitWave
	String origName = ImageNameWave[imgNum]
	
	DoWindow/K imgPlot
	NewImage/N=imgPlot/HIDE=1 ParentImgMat
	AppendToGraph/W=imgPlot/L/T cdW[][2] vs cdW[][1]
	ModifyGraph/W=imgPlot mode=3,marker=8
	Duplicate/O/RMD=[][3,3] cdQWave, w0,w1,w2 // using col3 of cdQ
		// find the max value of particles at the membrane
		w2[] = (cdQWave[p][4] == 2) ? w2[p] : NaN
		Variable zMax = WaveMax(w2)
		// deal with the case of no particles at membrane
		if (numtype(zMax) == 2)
			zMax = 1.5
		endif
		// find the max value of particles outside the cell, i.e. in area 0
		w1[] = (cdQWave[p][4] == 0) ? w1[p] : NaN
		Variable zMin = WaveMax(w1)
		// deal with the case of no particles
		if (numtype(zMin) == 2)
			zMin = max((zMax - 1.3336),0.5) // zMin is on average 1.3336 less than zMax, but deal with the case that this is too low
		endif
		// because we want to colour particles > zMin and not >= zMin (and only <= zMax)
		zMin += 0.000001
		LimitWave[imgNum][0] = zMin
		LimitWave[imgNum][1] = zMax
	ModifyGraph/W=imgPlot zColor={w0,zMin,zMax,YellowHot,0}, zColorMin=NaN, zColorMax=NaN
	TextBox/W=imgPlot/C/N=text0/F=0/A=RB/X=1.00/Y=1.00 origName
	
	Variable pgNum = floor(imgNum / 6) + 1 // 1st page is pg 1
	SavePICT/WIN=imgPlot/E=-5/RES=300/W=(0,0,354,248) as "Clipboard"
	LoadPICT/O/Q "Clipboard", $spotName
	AppendLayoutObject/W=summaryLayout/PAGE=(pgnum) picture $spotName
	DoWindow/K imgPlot
End

///	@param	nFiles	total number of TIFFs
///	@param	plotNum	number of plots per page
Function TileLayout(nFiles,plotNum)
	Variable nFiles,plotNum
	Variable pgMax = floor((nFiles -1) / plotNum) + 1
	
	Variable i
	
	DoWindow /F summaryLayout
	for(i = 1; i < pgMax + 1; i += 1)
		LayoutPageAction/W=summaryLayout page=(i)
		Execute /Q "Tile"
	endfor
	SavePICT/PGR=(1,-1)/E=-2 as "summary.pdf"
End

// Kill CMap wave if it has been loaded
Function KillCMaps()
	String wList = WaveList("CMap*",";","")
	Variable nWaves = ItemsInList(wList)
	String wName
	
	Variable i
	
	for(i = 0; i < nWaves; i += 1)
		wName = StringFromList(i,wList)
		KillWaves/Z $wName
	endfor
End

Function CountValidParticles()
	String wList = WaveList("cdQ*",";","")
	Variable nWaves = ItemsInList(wList)
	String cdQName
	Variable nFT,zMin,zMax
	Make/O/N=(nWaves,4) countWave
	WAVE/Z LimitWave
	
	// Print results to Notebook
	NewNotebook/F=0/N=tallyNotes
	String text0
	
	Variable i,j
	
	for(i = 0; i < nWaves; i += 1)
		cdQName = StringFromList(i,wList)
			Notebook tallyNotes, text=cdQName, text=": "
		Wave cdQWave = $cdQName
		nFT = dimsize(cdQwave,0)
		Make/O/N=(nFT)/FREE w1 // using col3 of cdQ
		// find the max value of particles outside the cell, i.e. in area 0
		w1[] = (cdQWave[p][4] == 0) ? cdQWave[p][3] : NaN
			WaveStats/Q w1
			text0 = num2str(V_npnts)
			Notebook tallyNotes, text=text0, text=" in z0. zMin="
		zMin = LimitWave[i][0]
			text0 = num2str(zMin)
			Notebook tallyNotes, text=text0, text=". "
		// find the max value of particles at the membrane
		w1[] = (cdQWave[p][4] == 2) ? cdQWave[p][3] : NaN
			WaveStats/Q w1
			text0 = num2str(V_npnts)
			Notebook tallyNotes, text=text0, text=" in z2. zMax="
		zMax = LimitWave[i][1]
			text0 = num2str(LimitWave[i][1])
			Notebook tallyNotes, text=text0, text=".\r"
		for(j = 0; j < 4; j += 1)
			w1[] = (cdQWave[p][3] > zMin && cdQWave[p][3] <= zMax) ? 1 : 0
			// filter for each zone
			w1[] = (cdQWave[p][4] == j) ? w1[p] : 0
			countWave[i][j] = sum(w1)
		endfor
		// test for two things, add 1 to col 2 of limitWave or 0 if OK
		Variable nDetects = countWave[i][1] + countWave[i][2]
		// is zMin > zMax?
		if(zMin > zMax)
			limitWave[i][2] = 1
		// or is the number of particles ridiculous
		elseif(nDetects > 40)
			limitWave[i][2] = 1
		else
			limitWave[i][2] = 0
		endif
	endfor
End

Function CalculateDensities()
	WAVE/Z countWave
	WAVE/Z volumeWave
	WAVE/Z limitWave
	String text0,text1
	
	Duplicate/O volumeWave, volCorrWave
	volCorrWave = (limitWave[p][2] == 1) ? 0 : volCorrWave[p][q]
	MatrixOp/O countTotal = sumcols(countWave)
	MatrixOp/O volumeTotal = sumcols(volCorrWave)
	MatrixOp/O densityWave = sumcols(countWave) / sumcols(volCorrWave)
	// Print results to Notebook
	KillWindow/Z summaryNotes
	NewNotebook/F=0/N=summaryNotes
	text0 = num2str(countTotal[0][1])
	text1 = num2str(volumeTotal[0][1])
	Notebook summaryNotes, text=text0, text=" particles were detected in ", text=text1, text=" µm^3 of cytoplasm.\r"
	text0 = num2str(countTotal[0][2])
	text1 = num2str(volumeTotal[0][2])
	Notebook summaryNotes, text=text0, text=" particles were detected in ", text=text1, text=" µm^3 of membrane zone.\r"
	text0 = num2str(countTotal[0][0])
	Notebook summaryNotes, text=text0, text=" particles were detected outside the cell.\r\r"
	text0 = num2str(densityWave[0][1])
	text1 = num2str(densityWave[0][2])
	Notebook summaryNotes, text="The cytoplasmic density was ", text=text0
	Notebook summaryNotes, text=" and the membrane density was ", text=text1, text=" particles per µm^3.\r"
	text0 = num2str(densityWave[0][2] / densityWave[0][1])
	Notebook summaryNotes, text="An enrichment of ", text=text0, text="-fold.\r"
End

// Destructive function that will get rid of everything
Function CoastClear()
	String fullList = WinList("*", ";","WIN:3")
	Variable allItems = ItemsInList(fullList)
	String name
	Variable i
 
	for(i = 0; i < allItems; i += 1)
		name = StringFromList(i, fullList)
		DoWindow/K $name		
	endfor
	
	// Look for data folders
	DFREF dfr = GetDataFolderDFR()
	allItems = CountObjectsDFR(dfr, 4)
	for(i = 0; i < allItems; i += 1)
		name = GetIndexedObjNameDFR(dfr, 4, i)
		KillDataFolder $name		
	endfor
	
	KillWaves/A/Z
	KillStrings/A/Z
	KillVariables/A/Z
End

Function GetPixelData()
	LoadWave/A/W/J/D/O/K=1/L={0,1,0,1,1}
	LoadWave/A/W/J/D/O/K=2/L={0,1,0,0,1} S_Path + S_fileName
End

// This function will save out a csv for import into R
// It is written to pull out coords and corresponding zones for
// "real particles".
/// @param	fileName	string of tiffname (without extension)
Function ExportRealParticles(fileName)
	String fileName
	WAVE/Z ImageNameWave
	if(!WaveExists(ImageNameWave))
		Abort "I need ImageNameWave"
	endif
	FindValue/TEXT=fileName ImageNameWave
	if (V_Value == -1)
		Print "Couldn't find", fileName 
	endif
	
	String mName = "cdW" + num2str(V_Value)
	Wave m0 = $mName
	MatrixOp/O cX = col(m0,1) // x coord in pixels
	MatrixOp/O cY = col(m0,2) // y coord in pixels
	mName = ReplaceString("cdW",mName,"cdQ")
	Wave m1 = $mName
	MatrixOp/O cZ = col(m1,4) // zone for each particle
	MatrixOp/O cQ = col(m1,3) // quality
	// get the limits for acceptance
	WAVE/Z LimitWave
	Variable zMin = limitWave[V_Value][0]
	Variable zMax = limitWave[V_Value][1]
	cX = (cQ[p] > zMin && cQ[p] < zMax) ? cX[p] : NaN
	cY = (cQ[p] > zMin && cQ[p] < zMax) ? cY[p] : NaN
	cZ = (cQ[p] > zMin && cQ[p] < zMax) ? cZ[p] : NaN
	WaveTransform zapNans cX
	WaveTransform zapNans cY
	WaveTransform zapNans cZ
	Concatenate/O {cX,cY,cZ}, expWave
	KillWaves/Z cQ
	fileName = fileName + ".txt"
	Save/J/M="\n" expWave as fileName
End